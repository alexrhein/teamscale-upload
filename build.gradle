import org.apache.tools.ant.taskdefs.condition.Os
import org.gradle.api.tasks.testing.logging.TestExceptionFormat

plugins {
	id 'org.beryx.runtime'
}

repositories {
	maven {
		url "https://packages.jetbrains.team/maven/p/ij/intellij-dependencies/"
	}
	mavenCentral()
}

group = "com.teamscale"
version = "1.0-SNAPSHOT"

application {
	applicationName = 'teamscale-upload'

	mainClass = 'com.teamscale.upload.TeamscaleUpload'

	applicationDefaultJvmArgs = [
			// Ensure that no stack traces are lost.
			// See <https://stackoverflow.com/questions/2411487/nullpointerexception-in-java-with-no-stacktrace>
			'-XX:-OmitStackTraceInFastThrow',
	]
}

java {
	toolchain {
		// Ensure that we build with the same version that we want to jlink to the distribution.
		// Before making this explicit, I got this error in the build: "Error: Error reading module: /home/runner/work/teamscale-upload/teamscale-upload/build/jdks/linux-x86_64/jdk-17.0.5+8/jmods/java.security.sasl.jmod"
		// I think the build was using Java 11 then.
		languageVersion = JavaLanguageVersion.of(17)
		// I would like to also use the same vendor as in jlink, but gradle can't find/download a toolchain for this vendor
		//vendor = JvmVendorSpec.ADOPTIUM
	}
}

dependencies {
	implementation group: 'org.apache.commons', name: 'commons-exec', version: '1.3'
	implementation group: 'commons-io', name: 'commons-io', version: '2.11.0'
	implementation group: 'org.apache.commons', name: 'commons-compress', version: '1.21'
	implementation group: 'org.apache.commons', name: 'commons-lang3', version: '3.12.0'
	implementation group: 'com.google.code.gson', name: 'gson', version: '2.8.9'
	implementation group: 'com.google.guava', name: 'guava', version: '32.1.2-jre'
	implementation group: 'com.squareup.okhttp3', name: 'okhttp', version: '4.9.2'
	implementation group: 'net.sourceforge.argparse4j', name: 'argparse4j', version: '0.9.0'
	implementation group: 'org.jetbrains.nativecerts', name: 'jvm-native-trusted-roots', version: '1.0.19'

	testImplementation group: 'com.sparkjava', name: 'spark-core', version: '2.9.4'

	testImplementation platform("org.junit:junit-bom:5.10.2")
	testImplementation 'org.junit.jupiter:junit-jupiter-api'
	testImplementation 'org.junit.jupiter:junit-jupiter-params'
	testRuntimeOnly  'org.junit.jupiter:junit-jupiter-engine'

	testImplementation group: 'org.assertj', name: 'assertj-core', version: '3.21.0'
	testRuntimeOnly group: 'javax.servlet', name: 'javax.servlet-api', version: '4.0.1'

	testRuntimeOnly("org.junit.platform:junit-platform-launcher")
}

def RUNTIME_JDK_VERSION = '17.0.5+8'

runtime {
	options = [
			'--compress', '2', // ZIP compression
			'--no-header-files', '--no-man-pages',
			'--dedup-legal-notices', 'error-if-not-same-content',
			'--strip-debug',
	]

	modules = [
			'java.logging', // For package java.util.logging (used by Google Guava)
			'java.naming', // For package javax.naming (used by Apache HttpClient)
			'jdk.crypto.ec', // For Elliptic Curve algorithms over TLS
			'jdk.unsupported', // For GSON
	]

	def ADOPTIUM_BINARY_REPOSITORY = 'https://api.adoptium.net/v3/binary'

	// We need to download the JDK, not the JRE, as the latter doesn't ship the jmod files needed by jlink
	targetPlatform('linux-x86_64') {
		jdkHome = jdkDownload("$ADOPTIUM_BINARY_REPOSITORY/version/jdk-${RUNTIME_JDK_VERSION}/linux/x64/jdk/hotspot/normal/eclipse") {
			archiveExtension = 'tar.gz'
		}
	}
	targetPlatform('windows-x86_64') {
		jdkHome = jdkDownload("$ADOPTIUM_BINARY_REPOSITORY/version/jdk-${RUNTIME_JDK_VERSION}/windows/x64/jdk/hotspot/normal/eclipse") {
			archiveExtension = 'zip'
		}
	}
	targetPlatform('macos-x86_64') {
		jdkHome = jdkDownload("$ADOPTIUM_BINARY_REPOSITORY/version/jdk-${RUNTIME_JDK_VERSION}/mac/x64/jdk/hotspot/normal/eclipse") {
			archiveExtension = 'tar.gz'
		}
	}
	targetPlatform('macos-aarch64') {
		jdkHome = jdkDownload("$ADOPTIUM_BINARY_REPOSITORY/version/jdk-${RUNTIME_JDK_VERSION}/mac/aarch64/jdk/hotspot/normal/eclipse") {
			archiveExtension = 'tar.gz'
		}
	}
	imageDir.set(layout.buildDirectory.dir("runtime/install"))
	imageZip.set(layout.buildDirectory.file("runtime/zip/${application.applicationName}.zip"))
}

// Use afterEvaluate to defer this logic until the configuration phase is complete.
// This guarantees that 'extensions.runtime.targetPlatforms' is populated.
project.afterEvaluate {
	// We still need to .get() here, but it's now safe inside afterEvaluate.
	extensions.runtime.targetPlatforms.get().each { targetPlatform ->
		tasks.register("customRuntimeZip-${targetPlatform.key}", Zip) {
			group = 'Build'
			description = "Builds a custom runtime zip for ${targetPlatform.key}"

			dependsOn tasks.named('runtime')

			// The doFirst check is an execution-time action, so it's perfectly fine.
			doFirst {
				// It's better to check the target, not the build host, for this logic.
				// If building a linux zip on Windows is the issue, this check is correct.
				if (Os.isFamily(Os.FAMILY_WINDOWS) && !targetPlatform.key.contains('windows')) {
					throw new GradleException("Can't build non-Windows distributions on a Windows host due to lost file permissions. Target was: ${targetPlatform.key}.")
				}
			}

			// --- LAZY PROPERTY ASSIGNMENTS ---
			// Use .set() for modern lazy properties instead of direct assignment (=).
			destinationDirectory.set(layout.buildDirectory.dir('distributions'))
			// Use a provider for the applicationName to ensure it's also lazy.
			archiveFileName.set("${application.applicationName}-${targetPlatform.key}.zip")

			// --- LAZY FILE SELECTION ---
			// The content of the zip is configured lazily.
			from(runtime.imageDir.dir("${project.name}-${targetPlatform.key}")) {
				into(application.applicationName) // applicationName is a Provider
			}

			// Select the README lazily based on the targetPlatform, not the build OS.
			// This makes the build more reliable and portable.
			from(project.provider {
				if (targetPlatform.key.contains('windows')) {
					return "distribution_readme/README_WINDOWS.md"
				} else {
					return "distribution_readme/README_UNIX.md"
				}
			}) {
				rename { "README.md" }
				into(application.applicationName)
			}
		}
	}
}

test {
	useJUnitPlatform()
	filter {
		// Don't run the integration test for the graal-vm distribution artifact here. (This is the jlink build.)
		excludeTestsMatching('com.teamscale.upload.NativeImageIT')
	}
	testLogging {
		outputs.upToDateWhen { false }
		showStandardStreams = true
		showExceptions = true
		showCauses = true
		exceptionFormat = TestExceptionFormat.FULL
	}
}
